library(shiny)
library(ggplot2)
library(reshape2)
load("results/COVID_FLU_2016_20231229_res2.RData")
colnames(df) <- c("probabilities", "signals", "logOR","lower","upper","time","AE")

ui <- navbarPage(
  title = "Variational Inference Safety Adjusted (VISA) Study",
  
  # Page 1: Current COVID vs FLU results
  tabPanel("COVID-19 vs FLU",
           sidebarLayout(
             sidebarPanel(
               uiOutput("dynamicAEs"),  # This will dynamically generate the AE select input
               selectInput("orderCriterion", "Order By:", choices = c("Risk Probabilities" = "probabilities", "logOR" = "logOR")),
               selectInput("orderTimePoint", "Select Time Point:", choices = c(1:max(df$time)))
             ),
             mainPanel(
               tabsetPanel(
                 tabPanel("Risk Probability", plotOutput("riskPlot"), downloadButton("downloadRiskPlot", "Download Risk Probability Plot")),
                 tabPanel("logOR Analysis", plotOutput("logORPlot"), downloadButton("downloadLogORPlot", "Download logOR Plot"))
               )
             )
           )
  ),
  
  # Page 2: Data Upload and Model Fitting
  tabPanel("Model Fitting",
           sidebarLayout(
             sidebarPanel(
               fileInput("newData", "Upload New Data CSV:", accept = c(".csv")),
               fileInput("fittedModel", "Upload Previous Model RData:", accept = c(".rda", ".RData")),
               actionButton("fitModel", "Fit Model"),
               downloadButton("downloadResults", "Download Results")
             ),
             mainPanel(
               plotOutput("modelPlot")
             )
           )
  )
)


server <- function(input, output, session) {
  
  # Dynamic UI for AE selection
  output$dynamicAEs <- renderUI({
    req(input$orderCriterion, input$orderTimePoint)
    
    # Filter the data for the selected time point
    timePointData <- df[df$time == input$orderTimePoint, ]
    
    # Order the AEs based on the selected criterion
    ordered_AEs <- timePointData[order(timePointData[[input$orderCriterion]], decreasing = TRUE), "AE"]
    unique_ordered_AEs <- unique(ordered_AEs)  # Ensure AEs are unique
    
    selectInput("selectedAEs", "Select Adverse Events:",
                choices = unique_ordered_AEs, multiple = TRUE, selectize = TRUE)
  })
  
  observe({
    # Get all unique time points
    unique_time_points <- sort(unique(df$time))
    
    # Update the select input for time points
    updateSelectInput(session, "orderTimePoint", 
                      choices = unique_time_points)
  })
  # Assuming the rest of your server logic remains relevant
  # Filtered Data based on selected AEs
  filteredData <- reactive({
    req(input$selectedAEs)
    # Adjust the filtering logic according to your actual data structure
    dataframe <- df[df$AE %in% input$selectedAEs, ]
  })
  
  output$riskPlot <- renderPlot({
    req(filteredData())
    data_to_plot <- filteredData()
    ggplot(data_to_plot, aes(x = time, y = probabilities, color = AE)) +
      geom_line() +
      geom_point()+
      ylim(0, 1) +
      theme_minimal() +
      geom_hline(yintercept = 0.975, linetype = "dashed", color = "red") +
      xlab("Time") + ylab("Risk Probability") +
      ggtitle("Risk Probability of Selected Adverse Events Over Time")
  })
  
  output$downloadRiskPlot <- downloadHandler(
    filename = function() {
      paste("risk-probability-plot-", Sys.Date(), ".png", sep = "")
    },
    content = function(file) {
      # Generate the plot
      plot <- ggplot(filteredData(), aes(x = time, y = probabilities, color = AE)) +
        geom_line() +
        ylim(0, 1) +
        theme_minimal() +
        geom_hline(yintercept = 0.975, linetype = "dashed", color = "red") +
        xlab("Time") + ylab("Risk Probability") +
        ggtitle("Risk Probability of Selected Adverse Events Over Time")
      
      # Save the plot to the specified file
      ggsave(file, plot, width = 10, height = 6)
    }
  )
  # New plot for logOR
  output$logORPlot <- renderPlot({
    req(filteredData())  # Make sure filteredData contains the required CI columns
    data_to_plot <- filteredData()
    
    ggplot(data_to_plot, aes(x = time, y = logOR, color = AE)) +
      geom_line() +  # Plot the logOR over time
      geom_point()+
      geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.15, linetype = "dashed",linewidth=0.5) +  # Add CI with geom_ribbon
      theme_minimal() +
      xlab("Time") + ylab("logOR") +
      ggtitle("logOR of Selected Adverse Events Over Time with Confidence Intervals")
  })
  
  output$downloadLogORPlot <- downloadHandler(
    filename = function() {
      paste("logOR-plot-", Sys.Date(), ".png", sep = "")
    },
    content = function(file) {
      # Generate the plot
      plot <- ggplot(filteredData(), aes(x = time, y = logOR, color = AE)) +
        geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.15, linetype = "dashed",linewidth=0.5)+
        geom_line() +
        theme_minimal() +
        xlab("Time") + ylab("logOR") +
        ggtitle("logOR of Selected Adverse Events Over Time with Confidence Intervals")
      
      # Save the plot to the specified file
      ggsave(file, plot, width = 10, height = 6)
    }
  )
  
  
  # Model Fitting logic remains unchanged
  observeEvent(input$fitModel, {
    # Model fitting and plotting logic as previously defined
  })
}

# ui <- navbarPage(
#   title = "Variational Inference Safety Adjusted (VISA) Study",
# 
#   # Page 1: Current COVID vs FLU results
#   tabPanel("COVID-19 vs FLU",
#            sidebarLayout(
#                  sidebarPanel(
#                    uiOutput("dynamicAEs", ),
#                    selectInput("timePoint1", "Select Time Point 1:", choices = 1:tps, selected = 1),
#                    radioButtons("signal1", "Status at Time Point 1", choices = c("Signal", "Non-Signal"), selected = "Non-Signal"),
#                    selectInput("timePoint2", "Select Time Point 2:", choices = 1:tps, selected = 1),
#                    radioButtons("signal2", "Status at Time Point 2", choices = c("Signal", "Non-Signal"), selected = "Non-Signal"),
#                    selectInput("timePoint3", "Select Time Point 3:", choices = 1:tps, selected = 1),
#                    radioButtons("signal3", "Status at Time Point 3", choices = c("Signal", "Non-Signal"), selected = "Non-Signal"),
#                  ),
# 
#                  mainPanel(
#                    plotOutput("riskPlot")
#                  )
#                )
#   ),
# 
#   # Page 2: Data Upload and Model Fitting
#   tabPanel("Model Fitting",
#            sidebarLayout(
#              sidebarPanel(
#                fileInput("newData", "Upload New Data CSV:", accept = c(".csv")),
#                fileInput("fittedModel", "Upload Previous Model RData:", accept = c(".rda", ".RData")),
#                actionButton("fitModel", "Fit Model"),
#                downloadButton("downloadResults", "Download Results")
#              ),
#              mainPanel(
#                plotOutput("modelPlot")
#                # Additional UI elements for model results can be added here
#              )
#            )
#   )
# )
# 
# server <- function(input, output) {
# 
#   # Page 1: Dynamic UI for AE selection
#     output$dynamicAEs <- renderUI({
#       # Filter based on signal data at three time points
#       filtered_AEs_1 <- signal_data[signal_data$time == input$timePoint1, ]
#       filtered_AEs_2 <- signal_data[signal_data$time == input$timePoint2, ]
#       filtered_AEs_3 <- signal_data[signal_data$time == input$timePoint3, ]
#       if (input$signal1 == "Signal") {
#         filtered_AEs_1 <- filtered_AEs_1[,filtered_AEs_1 == 1]
#       } else {
#         filtered_AEs_1 <- filtered_AEs_1[,filtered_AEs_1 == 0]
#       }
# 
#       if (input$signal2 == "Signal") {
#         filtered_AEs_2 <- filtered_AEs_2[,filtered_AEs_2 == 1]
#       } else {
#         filtered_AEs_2 <- filtered_AEs_2[,filtered_AEs_2 == 0]
#       }
# 
#       if (input$signal3 == "Signal") {
#         filtered_AEs_3 <- filtered_AEs_3[,filtered_AEs_3 == 1]
#       } else {
#         filtered_AEs_3 <- filtered_AEs_3[,filtered_AEs_3 == 0]
#       }
#       common_AEs <- Reduce(intersect, list(names(filtered_AEs_1)[-1], names(filtered_AEs_2)[-1], names(filtered_AEs_3)[-1]))
#       selectInput("selectedAEs", "Select Adverse Events:",
#                   choices = common_AEs, multiple = TRUE, selectize = TRUE)
#     })
# 
#     filteredData <- reactive({
#       req(input$selectedAEs)
#       df[c("time", input$selectedAEs)]
#     })
# 
#     output$riskPlot <- renderPlot({
#       req(filteredData())
#       data_to_plot <- filteredData()
#       melt_data <- melt(data_to_plot, id.vars = "time")
#       ggplot(melt_data, aes(x = time, y = value, color = variable)) +
#         geom_line() +
#         ylim(0,1)+
#         theme_minimal()+
#         geom_hline(yintercept = 0.975)+
#         xlab("Time") + ylab("Risk Probability") +
#         ggtitle("Risk Probability of Selected Adverse Events Over Time")
#     })
# 
# 
#   # Page 2: Model Fitting logic
#   observeEvent(input$fitModel, {
#     # Read new data
#     newData <- read.csv(input$newData$datapath)
# 
#     # Load the fitted model (if provided)
#     if (!is.null(input$fittedModel)) {
#       load(input$fittedModel$datapath)
#       # Assuming the loaded model is named 'fitted_model'
#       # Perform additional steps with 'fitted_model' and 'newData' as needed
#     }
# 
#     # Fit model on new data (example code, replace with actual model fitting)
#     # fitted_model <- some_model_function(newData)
# 
#     # Plotting results (example, replace with actual plotting code)
#     output$modelPlot <- renderPlot({
#       # Plotting code using 'fitted_model' and/or 'newData'
#       # Example: ggplot(newData, aes(x = variableX, y = variableY)) + geom_line()
#     })
# 
#     # Download results (example, adjust according to your actual results)
#     output$downloadResults <- downloadHandler(
#       filename = function() {
#         paste("model-results", Sys.Date(), ".csv", sep = "")
#       },
#       content = function(file) {
#         # Code to write the results to 'file'
#         # Example: write.csv(model_results, file)
#       }
#     )
#   })
# }

# Run the application
shinyApp(ui, server)
